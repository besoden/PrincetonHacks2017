var cache = ["No its course there's different versions of this depending on who you are depending on what your schedule is but in general everyone has a constraint of time in there for you have a constraint of what you can do in a given day.",
"Perhaps the one thing that binds all of us together but there are a few other things of course but time is certainly something that we share and the lack of time more importantly is something that always share.",
"Helping you spend your time effectively helping you focus for example when you're listening to podcast episode helping you focus on the right things and time is such an important topic is perhaps the one thing that binds.",
"In becoming a better developer sometimes means understanding more about how you spend your time that's what today's episode is about in fact reiliana midlevel what developer tears about helping you spend your time.",
"The most important time of my day and why I think that can be important for you to your listening to developer T my name is Jonathan control my goal is to help you become a better.",
"Or it may be that you very much enjoy the sunset in so seeing the sunset is particularly valuable to you there's not really a wrong answer here but I wanna share with you."];
// cached values.

var prefix = './output';
var extension = '.wav';
var num_clips = 6;

var url = "https://speech.platform.bing.com/speech/recognition/interactive/cognitiveservices/v1?language=en-US&format=detailed";
var method = "POST";
var postData = "Some data";

// You REALLY want shouldBeAsync = true.
// Otherwise, it'll block ALL execution waiting for server response.
var shouldBeAsync = false;// temporary hack to get around async annoying. todo: fix

var request = [];
for (let i = 0; i < num_clips; i++) {
    request[i] = new XMLHttpRequest();

    request[i].open(method, url, shouldBeAsync);
    request[i].setRequestHeader("Accept", "application/json;text/xml");
    request[i].setRequestHeader("Content-Type", "audio/wav; codec=audio/pcm; samplerate=16000");
    request[i].setRequestHeader("Ocp-Apim-Subscription-Key", getKey(readTextFile("keys")));
    request[i].onload = function () {
       // You can get all kinds of information about the HTTP response.
       status = request[i].status; // HTTP response status, e.g., 200 for "200 OK"
       data = request[i].responseText; // Returned data, e.g., an HTML document.
        // console.log(data);
        if (status == 200) {
            cache[i] = (JSON.parse(data))["NBest"][0]["Display"]; // update if we got a 200 code. technically not necessary but useful to show.
            console.log('updated entry ' + i);
        }
        if (i == num_clips - 1) {
            printSubtitles();
        }
    };
}
var status;
var data;

// returns a list of line-by-line content in the file
function readTextFile(file)
{
    var rawFile = new XMLHttpRequest();
    var allText;
    rawFile.open("GET", file, false);
    rawFile.onreadystatechange = function ()
    {
        if(rawFile.readyState === 4)
        {
            if(rawFile.status === 200 || rawFile.status == 0)
            {
                allText = rawFile.responseText.split(/\r?\n/);
                // alert(allText);
            }
        }
    }
    rawFile.send(null);
    return allText;
}
// gets key from a string array that was generated by readTextFile
function getKey(stringArray){
    return stringArray[1].substring(7);
}

// request.setRequestHeader("Host", "speech.platform.bing.com");
// request.setRequestHeader("Transfer-Encoding", "chunked");
// request.setRequestHeader("Expect", "100-continue");
var xhr = [];

for (let i = 0; i < num_clips; i++) {
    xhr.push(0);
}
for (let clip = 0; clip < num_clips; clip++) {
    var filename = prefix + (clip + 1) + extension;
    console.log('current clip: ' + filename);
    xhr[clip] = new XMLHttpRequest();
    xhr[clip].open("GET", filename);
    xhr[clip].responseType = "blob";
    var response = null;

    xhr[clip].onload = function() 
    {
        // analyze_data(xhr.response);
        // console.log(xhr[clip].response);
        request[clip].send(xhr[clip].response);
    }

    xhr[clip].send();
    // Actually sends the request to the server.
}

// every 14 seconds, update the subtitles.
function printSubtitles() {
    document.getElementById("subtitles").innerHTML = cache[0];
}